<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crossword Creator | English 1 Batam</title>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        pink: '#FF6B95',
                        orange: '#FF8C42',
                        green: '#00E676',
                        blue: '#2979FF',
                        dark: '#0f172a',
                        panel: '#1e293b',
                        surface: '#334155'
                    },
                    fontFamily: {
                        heading: ['Bebas Neue', 'sans-serif'],
                        body: ['Nunito', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    animation: {
                        'pop': 'pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                        'shake': 'shake 0.4s cubic-bezier(.36,.07,.19,.97) both',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        pop: {
                            '0%': { transform: 'scale(0.8)', opacity: '0.8' },
                            '100%': { transform: 'scale(1)', opacity: '1' },
                        },
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0)' }
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono:wght@400;700&family=Nunito:wght@400;600;800&display=swap" rel="stylesheet">

    <style>
        body { 
            font-family: 'Nunito', sans-serif;
            background-color: #0f172a;
            background-image: 
                radial-gradient(at 0% 0%, rgba(41, 121, 255, 0.15) 0px, transparent 50%), 
                radial-gradient(at 100% 100%, rgba(255, 107, 149, 0.1) 0px, transparent 50%);
            background-attachment: fixed;
            color: white;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Glassmorphism */
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        /* Grid System */
        #crossword-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            scrollbar-width: thin;
            scrollbar-color: #2979FF #1e293b;
            padding: 20px;
            display: flex;
            align-items: center; 
            justify-content: center;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        #crossword-grid {
            display: grid;
            gap: 4px; 
            background: transparent;
            margin: auto;
            transform-origin: center center;
            transition: transform 0.2s ease;
        }

        .cw-cell {
            position: relative;
            background: transparent;
            min-width: 55px; 
            min-height: 55px;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Empty Cell */
        .cw-cell.empty { opacity: 0; pointer-events: none; }

        /* Active Letter Cell */
        .cw-cell.filled {
            background: #1e293b;
            border: 2px solid rgba(255,255,255,0.1);
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        
        /* Locked (Correct) Cell */
        .cw-cell.locked {
            background: #00E676 !important;
            border-color: #00E676 !important;
            box-shadow: none !important;
            transform: scale(1);
        }
        .cw-cell.locked input { color: #004d26; pointer-events: none; }

        /* The Input Box */
        .cw-cell input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            text-align: center;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.8rem;
            font-weight: 800;
            text-transform: uppercase;
            padding: 0;
            outline: none;
            z-index: 2;
            cursor: pointer;
            caret-color: #2979FF;
            text-shadow: 0 2px 0 rgba(0,0,0,0.3);
        }

        /* Small number in corner */
        .cw-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.4);
            font-family: 'Nunito', sans-serif;
            z-index: 1;
            pointer-events: none;
            font-weight: bold;
        }

        /* --- STATE STYLES --- */
        .cw-cell.word-highlight {
            background: rgba(41, 121, 255, 0.15) !important;
            border-color: rgba(41, 121, 255, 0.4) !important;
            transform: scale(1.05);
            z-index: 5;
        }

        .cw-cell.cell-focused {
            background: #2979FF !important;
            border-color: #2979FF !important;
            transform: scale(1.15);
            z-index: 10;
            box-shadow: 0 10px 25px rgba(41, 121, 255, 0.5);
        }

        .cw-cell.error { animation: shake 0.4s; background: #FF6B95 !important; border-color: #FF6B95 !important; }
        .cw-cell.reveal input { color: #FF6B95; }

        /* Clue List */
        .clue-item {
            cursor: pointer;
            transition: all 0.2s;
            padding: 10px 14px;
            border-radius: 8px;
            border-left: 4px solid transparent;
            font-size: 1rem;
            margin-bottom: 6px;
            background: rgba(255,255,255,0.02);
        }
        .clue-item:hover { background: rgba(255,255,255,0.05); }
        .clue-item.active { 
            background: rgba(41, 121, 255, 0.15); 
            color: white; 
            border-left-color: #2979FF;
            font-weight: bold;
        }
        .clue-item.solved { opacity: 0.4; text-decoration: line-through; pointer-events: none; }

        /* --- PRINT STYLES --- */
        @media print {
            body { background: white; color: black; background-image: none; padding: 0; font-size: 11pt; }
            .no-print { display: none !important; }
            .print-only { display: block !important; }
            
            #game-container { box-shadow: none; border: none; background: none; display: block; }
            #crossword-container { background: none; border: none; overflow: visible; display: block; width: 100%; padding: 0; }
            #crossword-grid { width: 100% !important; transform: none !important; margin-bottom: 30px; gap: 0; border: 2px solid black; }
            
            .cw-cell.filled {
                background: white !important;
                border: 1px solid black !important;
                border-radius: 0 !important;
                box-shadow: none !important;
                min-width: 40px; min-height: 40px; width: 40px; height: 40px;
                transform: none !important;
            }
            .cw-cell input { color: transparent; font-size: 16pt; }
            .cw-number { color: black; font-weight: bold; font-size: 9pt; top: 1px; left: 2px; }

            .cw-cell.reveal-print input { color: black !important; font-weight: bold; }
            
            .clue-section { border: none !important; background: none !important; padding: 0 !important; page-break-inside: avoid; }
            .clue-item { color: black !important; padding: 2px 0; border: none; font-size: 12pt; background: none !important; }
            h3 { color: black !important; border-bottom: 2px solid black; margin-top: 20px; }
            
            .print-columns { column-count: 2; column-gap: 40px; }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Navbar -->
    <header class="w-full glass-panel border-b border-white/10 sticky top-0 z-50 no-print">
        <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-gradient-to-br from-blue to-pink w-10 h-10 rounded-lg flex items-center justify-center text-xl shadow-lg">
                    <i data-lucide="pen-tool" class="text-white w-6 h-6"></i>
                </div>
                <div>
                    <h1 class="text-2xl font-heading tracking-wider text-white leading-none">CROSSWORD</h1>
                    <div class="text-[10px] font-mono text-gray-400 tracking-widest">ENGLISH 1 BATAM</div>
                </div>
            </div>

            <div class="flex items-center gap-3">
                <button id="solution-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors text-orange" title="Reveal Solution">
                    <i data-lucide="eye" class="w-5 h-5"></i>
                </button>
                <button onclick="window.print()" class="p-2 rounded-full hover:bg-white/10 transition-colors text-blue" title="Print Worksheet">
                    <i data-lucide="printer" class="w-5 h-5"></i>
                </button>
                <button id="setup-btn" class="bg-pink text-white px-4 py-2 rounded-lg font-bold text-sm tracking-wide shadow-lg hover:brightness-110 transition">
                    SETUP
                </button>
            </div>
        </div>
    </header>

    <!-- Print Header -->
    <div class="print-only hidden w-full max-w-4xl mx-auto p-8 mb-4">
        <div class="text-center mb-8 border-b-2 border-black pb-4">
            <h1 class="text-4xl font-bold uppercase mb-2">Crossword Puzzle</h1>
        </div>
        <div class="flex justify-between text-lg mb-4">
            <div>Name: <span class="border-b border-black w-48 inline-block"></span></div>
            <div>Date: <span class="border-b border-black w-48 inline-block"></span></div>
        </div>
        <div class="flex justify-between text-lg mb-8">
            <div>Class: <span class="border-b border-black w-48 inline-block"></span></div>
            <div>Score: <span class="border-b border-black w-24 inline-block"></span></div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-grow p-4 md:p-8 flex justify-center h-full">
        <div id="game-container" class="glass-panel w-full max-w-[1600px] rounded-2xl p-6 flex flex-col lg:flex-row gap-8 transition-opacity duration-500 min-h-[700px]">
            
            <!-- Left: Grid Area -->
            <div class="flex-[2] flex flex-col h-full min-h-[600px] relative">
                <!-- Zoom Controls -->
                <div class="flex justify-between items-center mb-4 px-2 no-print z-10">
                    <div class="text-sm font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                        <i data-lucide="move" class="w-4 h-4"></i> Puzzle Grid
                    </div>
                    <div class="flex items-center gap-2 bg-black/20 rounded-lg p-1">
                        <button id="zoom-out" class="p-2 hover:bg-white/10 rounded-md text-gray-300"><i data-lucide="minus" class="w-4 h-4"></i></button>
                        <span class="text-xs font-mono text-gray-400 w-12 text-center">ZOOM</span>
                        <button id="zoom-in" class="p-2 hover:bg-white/10 rounded-md text-gray-300"><i data-lucide="plus" class="w-4 h-4"></i></button>
                    </div>
                </div>

                <!-- Grid Container -->
                <div id="crossword-container" class="flex-1 relative">
                    <div id="crossword-grid">
                         <!-- Empty State -->
                         <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                            <i data-lucide="layout-grid" class="w-20 h-20 opacity-20 mb-4"></i>
                            <p class="text-xl font-bold">No puzzle active.</p>
                            <button onclick="document.getElementById('setup-btn').click()" class="text-blue hover:text-white underline mt-2 font-bold">Create New Puzzle</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right: Clues -->
            <div class="w-full lg:w-[400px] flex flex-col gap-4 h-auto lg:h-full overflow-hidden print-columns">
                
                <!-- Across -->
                <div class="clue-section bg-surface/20 p-5 rounded-xl border border-white/5 flex flex-col flex-1 min-h-[250px]">
                    <h3 class="text-blue font-bold uppercase tracking-wider mb-2 border-b border-white/10 pb-2 flex items-center gap-2 sticky top-0 bg-transparent text-lg">
                        <i data-lucide="arrow-right" class="w-5 h-5"></i> Across
                    </h3>
                    <div id="clues-across" class="space-y-1 text-sm text-gray-300 overflow-y-auto pr-2 custom-scrollbar flex-1">
                        <!-- Clues injected here -->
                    </div>
                </div>

                <!-- Down -->
                <div class="clue-section bg-surface/20 p-5 rounded-xl border border-white/5 flex flex-col flex-1 min-h-[250px]">
                    <h3 class="text-pink font-bold uppercase tracking-wider mb-2 border-b border-white/10 pb-2 flex items-center gap-2 sticky top-0 bg-transparent text-lg">
                        <i data-lucide="arrow-down" class="w-5 h-5"></i> Down
                    </h3>
                    <div id="clues-down" class="space-y-1 text-sm text-gray-300 overflow-y-auto pr-2 custom-scrollbar flex-1">
                        <!-- Clues injected here -->
                    </div>
                </div>

            </div>

        </div>
    </main>

    <!-- SETUP MODAL -->
    <div id="setup-modal" class="fixed inset-0 z-[100] hidden flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm animate-pop">
        <div class="glass-panel w-full max-w-xl rounded-2xl flex flex-col max-h-[90vh]">
            <div class="p-6 border-b border-white/10 flex justify-between items-center bg-black/20">
                <h2 class="text-2xl font-heading text-white tracking-wide">PUZZLE SETUP</h2>
                <button id="close-setup" class="text-gray-400 hover:text-white transition"><i data-lucide="x" class="w-6 h-6"></i></button>
            </div>
            
            <div class="p-6 overflow-y-auto space-y-6">
                
                <!-- Grid Size (Simplified) -->
                <div>
                     <label class="text-xs font-bold text-blue uppercase tracking-widest mb-2 block">Grid Density</label>
                     <div class="flex gap-2">
                         <button class="grid-btn px-4 py-2 bg-blue text-white rounded-lg font-bold text-xs shadow-lg" data-size="12">Compact (12x12)</button>
                         <button class="grid-btn px-4 py-2 bg-surface text-gray-400 rounded-lg font-bold text-xs" data-size="15">Standard (15x15)</button>
                         <button class="grid-btn px-4 py-2 bg-surface text-gray-400 rounded-lg font-bold text-xs" data-size="18">Large (18x18)</button>
                     </div>
                </div>

                <div>
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-widest mb-2">Word List (WORD : CLUE)</label>
                    <textarea id="word-input" 
                        class="w-full h-48 bg-dark border border-white/10 rounded-xl p-4 font-mono text-sm text-white focus:border-pink focus:ring-1 focus:ring-pink outline-none resize-none placeholder-gray-600" 
                        placeholder="CAT : A small pet&#10;DOG : A loyal friend"></textarea>
                </div>
                
                <!-- Presets -->
                <div>
                     <label class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-2 block">Quick Load</label>
                     <div class="flex gap-2 flex-wrap">
                        <button class="preset-btn px-3 py-1 bg-surface rounded-full text-xs text-gray-300 hover:text-white border border-white/10 transition-colors" 
                            data-text="TEACHER : The person who teaches&#10;STUDENT : The person who learns&#10;PENCIL : Used for writing&#10;ERASER : Removes pencil marks&#10;BOOK : Has pages to read&#10;DESK : Where you sit&#10;BOARD : Teacher writes on this">
                            üè´ Classroom
                        </button>
                        <button class="preset-btn px-3 py-1 bg-surface rounded-full text-xs text-gray-300 hover:text-white border border-white/10 transition-colors" 
                            data-text="RED : The color of fire&#10;BLUE : The color of the sky&#10;GREEN : The color of grass&#10;YELLOW : The color of the sun&#10;PURPLE : The color of grapes">
                            üé® Colors
                        </button>
                        <button class="preset-btn px-3 py-1 bg-surface rounded-full text-xs text-gray-300 hover:text-white border border-white/10 transition-colors" 
                            data-text="CAT : Meows and chases mice&#10;DOG : Barks and chases cats&#10;BIRD : Flies in the sky&#10;FISH : Swims in the water&#10;LION : King of the jungle">
                            ü¶Å Animals
                        </button>
                    </div>
                </div>
            </div>

            <div class="p-6 border-t border-white/10 bg-black/20">
                <button id="generate-btn" class="w-full bg-gradient-to-r from-blue to-pink text-white py-3 rounded-xl font-bold text-lg shadow-lg hover:brightness-110 transition-transform active:scale-95">
                    GENERATE PUZZLE
                </button>
            </div>
        </div>
    </div>

    <!-- AUDIO & LOGIC -->
    <script>
        lucide.createIcons();
        
        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const playTone = (freq, type, duration) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        };
        const Sound = {
            type: () => playTone(800, 'sine', 0.05),
            back: () => playTone(600, 'sine', 0.05),
            click: () => playTone(400, 'triangle', 0.05),
            success: () => { 
                playTone(500, 'sine', 0.1); 
                setTimeout(() => playTone(1000, 'sine', 0.2), 100); 
                setTimeout(() => playTone(1500, 'sine', 0.4), 200); 
            },
            error: () => playTone(150, 'sawtooth', 0.2)
        };

        // --- GAME STATE ---
        let GRID_SIZE = 12;
        let CELL_SIZE = 55; // Larger default
        let grid = [];
        let words = []; 
        let currentFocus = { r: -1, c: -1 };
        let currentDir = 'across'; 

        const els = {
            grid: document.getElementById('crossword-grid'),
            across: document.getElementById('clues-across'),
            down: document.getElementById('clues-down'),
            input: document.getElementById('word-input'),
            modal: document.getElementById('setup-modal'),
            empty: document.getElementById('empty-state')
        };

        // --- HANDLERS ---
        document.getElementById('setup-btn').onclick = () => els.modal.classList.remove('hidden');
        document.getElementById('close-setup').onclick = () => els.modal.classList.add('hidden');
        
        // Zoom Handlers
        document.getElementById('zoom-in').onclick = () => {
            CELL_SIZE = Math.min(CELL_SIZE + 5, 100);
            updateGridSize();
        };
        document.getElementById('zoom-out').onclick = () => {
            CELL_SIZE = Math.max(CELL_SIZE - 5, 30);
            updateGridSize();
        };

        function updateGridSize() {
            document.querySelectorAll('.cw-cell').forEach(el => {
                el.style.width = `${CELL_SIZE}px`;
                el.style.height = `${CELL_SIZE}px`;
                el.style.minWidth = `${CELL_SIZE}px`;
                el.style.minHeight = `${CELL_SIZE}px`;
                
                const fontSize = Math.max(0.8, CELL_SIZE / 30);
                const input = el.querySelector('input');
                if(input) input.style.fontSize = `${fontSize}rem`;
            });
        }
        
        document.querySelectorAll('.preset-btn').forEach(b => {
            b.onclick = () => els.input.value = b.dataset.text;
        });

        document.querySelectorAll('.grid-btn').forEach(b => {
            b.onclick = (e) => {
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.classList.remove('bg-blue', 'text-white', 'shadow-lg');
                    btn.classList.add('bg-surface', 'text-gray-400');
                });
                e.target.classList.remove('bg-surface', 'text-gray-400');
                e.target.classList.add('bg-blue', 'text-white', 'shadow-lg');
                GRID_SIZE = parseInt(e.target.dataset.size);
            };
        });

        document.getElementById('generate-btn').onclick = () => {
            const lines = els.input.value.split('\n').filter(l => l.includes(':'));
            if(lines.length < 2) { alert("Please add at least 2 words!"); return; }
            
            const inputData = lines.map(l => {
                const [w, c] = l.split(':');
                return { word: w.trim().toUpperCase().replace(/[^A-Z]/g, ''), clue: c.trim() };
            }).sort((a,b) => b.word.length - a.word.length);

            const success = generateLayout(inputData);
            if(success) {
                render();
                els.modal.classList.add('hidden');
                els.empty.classList.add('hidden');
                confetti({ particleCount: 50, spread: 60, origin: { y: 0.6 }, colors: ['#2979FF', '#FF6B95'] });
            } else {
                alert("Could not fit all words nicely. Try increasing Grid Density to Large.");
            }
        };

        // --- LAYOUT ENGINE (Improved Spacing) ---
        function generateLayout(inputWords) {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)); 
            words = [];
            
            const first = inputWords[0];
            const startR = Math.floor(GRID_SIZE/2);
            const startC = Math.floor((GRID_SIZE - first.word.length)/2);
            placeWord(first, startR, startC, 'across');

            const remaining = inputWords.slice(1);
            
            for(let pass = 0; pass < 20; pass++) {
                if(remaining.every(w => w.placed)) break;
                for(let i = 0; i < remaining.length; i++) {
                    const item = remaining[i];
                    if(item.placed) continue;
                    if(tryFitWord(item)) item.placed = true;
                }
            }

            words = words.filter(w => w.placed || w === words[0]); 
            words.sort((a,b) => (a.row - b.row) || (a.col - b.col));
            
            let num = 1;
            words.forEach((w, i) => {
                const existing = words.slice(0, i).find(prev => prev.row === w.row && prev.col === w.col);
                w.num = existing ? existing.num : num++;
            });

            return words.length >= Math.min(inputWords.length, 2); 
        }

        function placeWord(item, r, c, dir) {
            words.push({ ...item, row: r, col: c, dir: dir, placed: true });
            for(let i=0; i<item.word.length; i++) {
                const row = dir === 'across' ? r : r + i;
                const col = dir === 'across' ? c + i : c;
                grid[row][col] = item.word[i];
            }
        }

        function tryFitWord(item) {
            for(let i=0; i<item.word.length; i++) {
                const char = item.word[i];
                for(let r=0; r<GRID_SIZE; r++) {
                    for(let c=0; c<GRID_SIZE; c++) {
                        if(grid[r][c] === char) {
                            // Try Down
                            if(checkPlacement(item.word, r - i, c, 'down')) {
                                placeWord(item, r - i, c, 'down');
                                return true;
                            }
                            // Try Across
                            if(checkPlacement(item.word, r, c - i, 'across')) {
                                placeWord(item, r, c - i, 'across');
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // IMPROVED: Checks for unwanted neighbors ("Clutter check")
        function checkPlacement(word, startR, startC, dir) {
            // 1. Bounds Check
            if(startR < 0 || startC < 0) return false;
            if(dir === 'across' && startC + word.length > GRID_SIZE) return false;
            if(dir === 'down' && startR + word.length > GRID_SIZE) return false;

            // 2. Overlap & Neighbor Check
            for(let i=0; i<word.length; i++) {
                const r = dir === 'across' ? startR : startR + i;
                const c = dir === 'across' ? startC + i : startC;
                const currentVal = grid[r][c];
                const char = word[i];

                // A. Direct Collision (Letter Mismatch)
                if(currentVal !== null && currentVal !== char) return false;

                // B. "Social Distancing" (Avoid touching words parallel)
                // If this cell is empty (we are placing a new letter here),
                // ensure no parallel neighbors exist.
                if(currentVal === null) {
                    if(dir === 'across') {
                        // Check Top and Bottom neighbors
                        if(r > 0 && grid[r-1][c] !== null) return false;
                        if(r < GRID_SIZE-1 && grid[r+1][c] !== null) return false;
                    } else {
                        // Check Left and Right neighbors
                        if(c > 0 && grid[r][c-1] !== null) return false;
                        if(c < GRID_SIZE-1 && grid[r][c+1] !== null) return false;
                    }
                }
            }

            // 3. End Caps Check (Ensure word doesn't accidentally extend another word)
            if(dir === 'across') {
                if(startC > 0 && grid[startR][startC-1] !== null) return false; // Left
                if(startC + word.length < GRID_SIZE && grid[startR][startC + word.length] !== null) return false; // Right
            } else {
                if(startR > 0 && grid[startR-1][startC] !== null) return false; // Top
                if(startR + word.length < GRID_SIZE && grid[startR + word.length][startC] !== null) return false; // Bottom
            }

            return true;
        }

        // --- RENDER & INTERACTION ---
        function render() {
            els.grid.innerHTML = '';
            els.grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cw-cell ' + (grid[r][c] ? 'filled' : 'empty');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    cell.style.width = `${CELL_SIZE}px`;
                    cell.style.height = `${CELL_SIZE}px`;
                    cell.style.minWidth = `${CELL_SIZE}px`;
                    cell.style.minHeight = `${CELL_SIZE}px`;

                    if(grid[r][c]) {
                        const startWord = words.find(w => w.row === r && w.col === c);
                        if(startWord) {
                            const num = document.createElement('span');
                            num.className = 'cw-number';
                            num.innerText = startWord.num;
                            cell.appendChild(num);
                        }

                        const input = document.createElement('input');
                        input.maxLength = 1;
                        input.dataset.r = r;
                        input.dataset.c = c;
                        
                        input.addEventListener('mousedown', (e) => handleCellClick(e, r, c));
                        input.addEventListener('keydown', (e) => handleKeyDown(e, r, c));
                        // input.addEventListener('input', (e) => handleInput(e, r, c)); // Handled manually in KeyDown for control
                        
                        cell.appendChild(input);
                    }
                    els.grid.appendChild(cell);
                }
            }

            // Clues
            els.across.innerHTML = '';
            els.down.innerHTML = '';
            words.forEach(w => {
                const li = document.createElement('div');
                li.className = 'clue-item';
                li.id = `clue-${w.row}-${w.col}-${w.dir}`;
                li.innerHTML = `<span class="font-bold opacity-50 mr-2">${w.num}.</span> ${w.clue}`;
                li.onclick = () => selectWordByClue(w);
                if(w.dir === 'across') els.across.appendChild(li);
                else els.down.appendChild(li);
            });
            
            updateGridSize(); 
        }

        // --- NAVIGATION & REAL-TIME CHECK (IMPROVED) ---
        function handleCellClick(e, r, c) {
            Sound.click();
            if(currentFocus.r === r && currentFocus.c === c) {
                currentDir = currentDir === 'across' ? 'down' : 'across';
            } else {
                const hasAcross = words.some(w => w.dir === 'across' && r === w.row && c >= w.col && c < w.col + w.word.length);
                const hasDown = words.some(w => w.dir === 'down' && c === w.col && r >= w.row && r < w.row + w.word.length);
                if(hasAcross && !hasDown) currentDir = 'across';
                else if(!hasAcross && hasDown) currentDir = 'down';
            }
            updateHighlights(r, c);
        }

        function handleKeyDown(e, r, c) {
            const key = e.key.toUpperCase();
            
            // Allow typing letters A-Z
            if (key.length === 1 && key >= 'A' && key <= 'Z') {
                e.preventDefault(); // Stop default input to handle overwrite manually
                Sound.type();
                e.target.value = key;
                
                checkCurrentWordCompletion(r, c);
                
                // Smart Move: Skip filled cells
                jumpToNextCell(r, c);
                return;
            }

            if(e.key === 'Backspace') {
                e.preventDefault(); // Stop browser back
                
                // If current has value, clear it and stay (unless locked)
                // If empty, move back and clear
                if(e.target.value && !e.target.parentElement.classList.contains('locked')) {
                     e.target.value = '';
                     Sound.back();
                } else {
                     Sound.back();
                     jumpToPrevCell(r, c);
                }
            } 
            else if(e.key === 'ArrowRight') focusCell(r, c+1);
            else if(e.key === 'ArrowLeft') focusCell(r, c-1);
            else if(e.key === 'ArrowDown') focusCell(r+1, c);
            else if(e.key === 'ArrowUp') focusCell(r-1, c);
        }

        function jumpToNextCell(r, c) {
            // Find active word to know bounds
            const activeWord = words.find(w => 
                w.dir === currentDir && 
                (currentDir === 'across' ? (w.row === r && c >= w.col && c < w.col + w.word.length) 
                                         : (w.col === c && r >= w.row && r < w.row + w.word.length))
            );

            if(!activeWord) return; // Should not happen

            // Determine check direction
            const dr = currentDir === 'across' ? 0 : 1;
            const dc = currentDir === 'across' ? 1 : 0;
            
            let nextR = r + dr;
            let nextC = c + dc;

            // Loop to find next cell that is either empty OR not locked
            // But standard crossword behavior: Just jump to next cell in word, even if filled. 
            // USER REQUEST: "Problem if tile already filled" -> Implies skip filled.
            
            // Let's iterate until we find an empty cell OR end of word
            // Check max 15 steps to prevent infinite loop
            for(let i=0; i<15; i++) {
                 // Check if valid cell in grid
                 const cell = document.querySelector(`.cw-cell[data-r="${nextR}"][data-c="${nextC}"]`);
                 
                 // If no cell, or cell not part of this word (simple bound check), stop
                 if(!cell || !cell.classList.contains('filled')) break;
                 
                 const input = cell.querySelector('input');
                 
                 // If cell is empty, stop here and focus
                 if(!input.value) {
                     focusCell(nextR, nextC);
                     return;
                 }
                 
                 // If cell is filled... loop again to next
                 nextR += dr;
                 nextC += dc;
            }
            
            // If we reached here, word is full. 
            // Focus the very next cell (even if filled) to allow correction?
            // Or just stay at last input?
            // Let's just focus the immediate neighbor if we didn't find an empty one, so user isn't stuck.
            // Reset to immediate next
            focusCell(r + dr, c + dc);
        }

        function jumpToPrevCell(r, c) {
             const dr = currentDir === 'across' ? 0 : -1;
             const dc = currentDir === 'across' ? -1 : 0;
             
             let prevR = r + dr;
             let prevC = c + dc;
             
             // Simple move back, but skip locked cells?
             // Usually backspace just goes back one.
             
             const cell = document.querySelector(`.cw-cell[data-r="${prevR}"][data-c="${prevC}"]`);
             if(cell) {
                 const input = cell.querySelector('input');
                 if(input && !cell.classList.contains('locked')) {
                     input.value = ''; // Clear it
                     focusCell(prevR, prevC);
                 } else if (cell.classList.contains('locked')) {
                     // If locked, keep going back
                     jumpToPrevCell(prevR, prevC);
                 } else {
                     focusCell(prevR, prevC);
                 }
             }
        }

        function checkCurrentWordCompletion(r, c) {
            const activeWord = words.find(w => 
                w.dir === currentDir && 
                (currentDir === 'across' ? (w.row === r && c >= w.col && c < w.col + w.word.length) 
                                         : (w.col === c && r >= w.row && r < w.row + w.word.length))
            );

            if(!activeWord) return;

            let currentGuess = "";
            let isFull = true;
            const inputElements = []; 

            for(let i=0; i<activeWord.word.length; i++) {
                const checkR = activeWord.dir === 'across' ? activeWord.row : activeWord.row + i;
                const checkC = activeWord.dir === 'across' ? activeWord.col + i : activeWord.col;
                const cell = document.querySelector(`.cw-cell[data-r="${checkR}"][data-c="${checkC}"]`);
                const val = cell.querySelector('input').value.toUpperCase();
                
                if(!val) { isFull = false; break; }
                currentGuess += val;
                inputElements.push(cell);
            }

            if(isFull) {
                if(currentGuess === activeWord.word) {
                    Sound.success();
                    confetti({ particleCount: 30, spread: 40, origin: { y: 0.7 } });
                    
                    inputElements.forEach(cell => {
                        cell.classList.add('locked');
                        cell.classList.remove('cell-focused', 'word-highlight'); 
                    });
                    
                    const clueEl = document.getElementById(`clue-${activeWord.row}-${activeWord.col}-${activeWord.dir}`);
                    if(clueEl) clueEl.classList.add('solved');

                } else {
                    Sound.error();
                    inputElements.forEach(cell => {
                        cell.classList.add('error');
                        setTimeout(() => cell.classList.remove('error'), 400);
                    });
                }
            }
        }

        function focusCell(r, c) {
            const input = document.querySelector(`input[data-r="${r}"][data-c="${c}"]`);
            if(input) {
                input.focus();
                updateHighlights(r, c);
            }
        }

        function selectWordByClue(w) {
            currentDir = w.dir;
            focusCell(w.row, w.col);
            Sound.click();
        }

        function updateHighlights(r, c) {
            currentFocus = { r, c };
            document.querySelectorAll('.word-highlight').forEach(el => el.classList.remove('word-highlight'));
            document.querySelectorAll('.cell-focused').forEach(el => el.classList.remove('cell-focused'));
            document.querySelectorAll('.clue-item.active').forEach(el => el.classList.remove('active'));

            const focusedCell = document.querySelector(`.cw-cell[data-r="${r}"][data-c="${c}"]`);
            if(focusedCell) focusedCell.classList.add('cell-focused');

            const activeWord = words.find(w => 
                w.dir === currentDir && 
                (currentDir === 'across' ? (w.row === r && c >= w.col && c < w.col + w.word.length) 
                                         : (w.col === c && r >= w.row && r < w.row + w.word.length))
            );

            if(activeWord) {
                for(let i=0; i<activeWord.word.length; i++) {
                    const row = activeWord.dir === 'across' ? activeWord.row : activeWord.row + i;
                    const col = activeWord.dir === 'across' ? activeWord.col + i : activeWord.col;
                    const cell = document.querySelector(`.cw-cell[data-r="${row}"][data-c="${col}"]`);
                    if(cell) cell.classList.add('word-highlight');
                }
                const clueEl = document.getElementById(`clue-${activeWord.row}-${activeWord.col}-${activeWord.dir}`);
                if(clueEl) {
                    clueEl.classList.add('active');
                    clueEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        }

        document.getElementById('solution-btn').onclick = () => {
             document.querySelectorAll('input').forEach(inp => {
                const r = inp.dataset.r;
                const c = inp.dataset.c;
                inp.value = grid[r][c];
                inp.parentElement.classList.add('reveal');
                inp.parentElement.classList.add('reveal-print');
            });
            Sound.success();
        };

        // Init
        document.getElementById('setup-btn').click();

    </script>
</body>
</html>