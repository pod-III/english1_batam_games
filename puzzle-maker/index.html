<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Maker Pro - English 1 Batam</title>
    
    <!-- External Libraries -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        pink: '#FF6B95',
                        orange: '#FF8C42',
                        green: '#00E676',
                        blue: '#2979FF',
                        dark: '#1e293b',
                        chalk: '#f8fafc',
                    },
                    fontFamily: {
                        heading: ['Fredoka', 'sans-serif'], 
                        body: ['Nunito', 'sans-serif'],
                    },
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        /* ============================================
           BASE STYLES
           ============================================ */
        :root {
            --color-pink: #FF6B95;
            --color-orange: #FF8C42;
            --color-green: #00E676;
            --color-blue: #2979FF;
            --color-dark: #1e293b;
            --color-chalk: #f8fafc;
            --bg-primary: #F8FAFC;
            --bg-secondary: #FFFFFF;
            --text-primary: #1e293b;
            --border-primary: #1e293b;
            --border-width-medium: 4px; 
            --border-width-thick: 6px;
            --grid-color: #E2E8F0;
            --grid-size: 24px;
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        body { 
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-primary);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* --- Chunky Buttons --- */
        .btn-chunky {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-family: 'Fredoka', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: var(--border-width-medium) solid var(--border-primary);
            box-shadow: 0 4px 0 var(--border-primary);
            cursor: pointer;
            user-select: none;
            transition: all var(--transition-fast);
            transform: translateY(0);
            @apply rounded-xl px-4 py-3;
        }

        .btn-chunky:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 var(--border-primary);
        }

        .btn-chunky:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0 0 0 var(--border-primary);
        }

        .btn-chunky:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: 0 2px 0 var(--border-primary);
            background-color: #e2e8f0;
            color: #94a3b8;
        }

        /* --- Round/Page List Items --- */
        .round-item {
            @apply flex items-center gap-3 p-2 rounded-xl border-2 border-transparent cursor-pointer transition-all hover:bg-slate-50;
        }
        .round-item.active {
            @apply border-blue bg-blue/5;
        }
        .round-item img {
            @apply w-12 h-12 rounded-lg object-cover border-2 border-slate-200;
        }
        .round-item.active img {
            @apply border-blue;
        }

        .sidebar {
            width: 380px;
            background: var(--bg-secondary);
            border-right: var(--border-width-thick) solid var(--border-primary);
            padding: 1.5rem;
            height: 100vh;
            z-index: 50;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 0 rgba(30, 41, 59, 0.05);
            transition: margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .sidebar.hidden-panel {
            margin-left: -380px;
        }

        .main-area {
            flex: 1;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: auto;
            position: relative;
        }

        /* Fullscreen Toggle Button */
        #fullscreenToggle {
            @apply absolute top-6 left-6 z-40 bg-white border-4 border-dark rounded-xl p-2 cursor-pointer transition-transform hover:scale-105 active:scale-95 text-dark;
            box-shadow: 4px 4px 0 var(--border-primary);
        }

        #game-container {
            position: relative;
            box-shadow: 12px 12px 0px rgba(30, 41, 59, 0.1);
            border: var(--border-width-thick) solid var(--border-primary);
            border-radius: 28px;
            background: #fff;
            display: none;
            overflow: hidden;
            transition: transform var(--transition-bounce);
        }

        canvas { display: block; cursor: pointer; }

        .input-label { 
            @apply text-[11px] font-black text-slate-400 uppercase tracking-widest mb-3 flex items-center gap-2; 
        }

        .toggle-btn {
            @apply flex items-center justify-between p-4 rounded-xl border-4 border-dark bg-white transition-all cursor-pointer;
            box-shadow: 4px 4px 0 var(--border-primary);
        }
        .toggle-btn:hover { @apply bg-slate-50; }
        .toggle-btn:active { transform: translate(2px, 2px); box-shadow: 0px 0px 0 var(--border-primary); }
        .toggle-btn.active { @apply bg-blue text-white border-blue; box-shadow: 4px 4px 0 var(--color-dark); }
        .toggle-btn .toggle-icon { @apply transition-transform duration-300; }
        .toggle-btn.active .toggle-icon { @apply scale-110; }

        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.9) translateY(10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        .modal-overlay {
            @apply fixed inset-0 flex items-center justify-center z-[100] opacity-0 pointer-events-none transition-opacity duration-300;
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(8px);
        }
        .modal-overlay.active { @apply opacity-100 pointer-events-auto; }

        .modal-content {
            @apply bg-white p-10 rounded-[32px] border-4 border-dark w-[90%] max-w-[440px] text-center;
            box-shadow: 12px 12px 0px rgba(0,0,0,0.2);
        }
        
        .modal-overlay.active .modal-content {
            animation: pop-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        #thumb-preview {
            @apply absolute top-6 right-6 w-32 border-4 border-dark rounded-xl z-10 hidden bg-white p-1;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.1);
        }

        #toast {
            @apply fixed top-6 left-1/2 -translate-x-1/2 bg-dark text-white px-6 py-3 rounded-full shadow-xl transform -translate-y-24 transition-transform duration-300 z-[200] flex items-center gap-3 font-bold;
        }
        #toast.active { @apply translate-y-0; }

        /* --- PRINT STYLES --- */
        #print-area { display: none; }

        @media print {
            @page {
                size: A4;
                margin: 0; 
            }
            body, html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: white;
                overflow: visible;
            }
            
            .sidebar, .main-area, .modal-overlay, #thumb-preview, #liveStats, #toast, #fullscreenToggle { 
                display: none !important; 
            }

            #print-area {
                display: block !important;
                width: 100%;
                height: 100%;
            }

            .print-page {
                width: 210mm;
                height: 297mm;
                page-break-after: always;
                position: relative;
                padding: 0; 
                margin: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                box-sizing: border-box;
                overflow: hidden;
            }
            
            .print-page::after {
                content: attr(data-page-num);
                position: absolute;
                bottom: 10mm;
                right: 10mm;
                font-size: 10pt;
                color: #999;
                font-family: sans-serif;
            }

            .print-page:last-child {
                page-break-after: auto;
            }

            .print-full-img {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 0;
            }

            .print-full-img img {
                width: 100%;
                height: 100%;
                object-fit: contain; 
                border: none;
            }

            .print-page-ref {
                padding: 10mm;
                justify-content: flex-start;
            }

            .print-header {
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
                border-bottom: 3px solid #000;
                padding-bottom: 20px;
                margin-bottom: 40px;
            }
        }
    </style>
</head>
<body class="flex min-h-screen overflow-hidden">

    <!-- Toast -->
    <div id="toast">
        <i data-lucide="save" class="w-4 h-4 text-green"></i>
        <span>Game Saved</span>
    </div>

    <!-- Modal: Print Options -->
    <div id="printModal" class="modal-overlay">
        <div class="modal-content w-[500px] max-w-[95%]">
            <div class="w-20 h-20 bg-green/10 rounded-2xl flex items-center justify-center mx-auto mb-6 border-4 border-green -rotate-3" style="box-shadow: 4px 4px 0 var(--color-green)">
                <i data-lucide="printer" class="text-green w-10 h-10"></i>
            </div>
            <h3 class="font-heading text-3xl mb-2 text-dark">Print Settings</h3>
            <p class="text-slate-500 mb-8 font-body">Configure your worksheet layout.</p>
            
            <div class="space-y-4 mb-8 text-left">
                <!-- Option 1 -->
                <div class="p-4 rounded-xl border-4 border-slate-100 hover:border-blue/30 transition-colors flex items-center justify-between cursor-pointer" onclick="togglePrintOpt('puzzle')">
                    <div class="flex items-center gap-4">
                        <div class="w-10 h-10 bg-blue rounded-lg flex items-center justify-center text-white">
                            <i data-lucide="layers" class="w-5 h-5"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-dark font-heading">Puzzle Pages</h4>
                            <p class="text-xs text-slate-400 font-bold uppercase">Prints all <span id="printPageCount">1</span> rounds</p>
                        </div>
                    </div>
                    <div class="w-6 h-6 rounded-full bg-blue flex items-center justify-center">
                        <i data-lucide="check" class="w-4 h-4 text-white"></i>
                    </div>
                </div>

                <!-- Option 2 -->
                <div id="opt-reference" class="p-4 rounded-xl border-4 border-slate-100 hover:border-orange/30 transition-colors flex items-center justify-between cursor-pointer" onclick="togglePrintOpt('reference')">
                    <div class="flex items-center gap-4">
                        <div class="w-10 h-10 bg-orange rounded-lg flex items-center justify-center text-white">
                            <i data-lucide="image" class="w-5 h-5"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-dark font-heading">Answer Keys</h4>
                            <p class="text-xs text-slate-400 font-bold uppercase">Includes reference images</p>
                        </div>
                    </div>
                    <div id="check-reference" class="w-6 h-6 rounded-full bg-slate-200 flex items-center justify-center"></div>
                </div>
            </div>

            <div class="flex gap-4">
                <button onclick="closeModal('printModal')" class="flex-1 btn-chunky bg-white text-slate-500 border-slate-300 shadow-none">
                    CANCEL
                </button>
                <button onclick="executePrint()" class="flex-1 btn-chunky bg-green text-dark">
                    PRINT ALL <i data-lucide="printer" class="w-5 h-5 ml-2"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Modal: Win -->
    <div id="winnerModal" class="modal-overlay">
        <div class="modal-content">
            <div class="w-24 h-24 bg-green/10 rounded-full flex items-center justify-center mx-auto mb-6 border-4 border-green animate-bounce">
                <i data-lucide="trophy" class="text-green w-12 h-12"></i>
            </div>
            <h3 class="font-heading text-4xl mb-2 text-dark">AMAZING!</h3>
            <p class="text-slate-500 mb-8 font-body text-lg">You finished this page!</p>
            
            <div class="flex gap-4 mb-8">
                <div class="flex-1 bg-slate-50 p-4 rounded-2xl border-2 border-dark">
                    <span class="block text-[10px] font-black text-slate-400 uppercase">Time</span>
                    <span id="finalTime" class="text-2xl font-heading text-dark">00:00</span>
                </div>
                <div class="flex-1 bg-slate-50 p-4 rounded-2xl border-2 border-dark">
                    <span class="block text-[10px] font-black text-slate-400 uppercase">Moves</span>
                    <span id="finalMoves" class="text-2xl font-heading text-dark">0</span>
                </div>
            </div>

            <div class="flex gap-4">
                <button onclick="nextRound()" id="modalNextBtn" class="flex-1 btn-chunky bg-blue text-white" style="display:none">
                    NEXT ROUND <i data-lucide="arrow-right" class="w-4 h-4 ml-2"></i>
                </button>
                <button onclick="scramblePuzzle()" class="flex-1 btn-chunky bg-orange text-white">
                    <i data-lucide="rotate-ccw" class="w-4 h-4 mr-2"></i> REPLAY
                </button>
            </div>
            <button onclick="closeModal('winnerModal')" class="mt-4 text-xs font-bold text-slate-400 hover:text-dark uppercase">
                Close & Stay Here
            </button>
        </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar no-print" id="sidebar">
        <header class="mb-6">
            <div class="inline-flex items-center gap-4">
                <div class="w-14 h-14 bg-pink border-4 border-dark rounded-2xl flex items-center justify-center text-white" style="box-shadow: 4px 4px 0 var(--color-dark)">
                    <i data-lucide="puzzle" class="w-7 h-7"></i>
                </div>
                <div class="text-left">
                    <h1 class="text-2xl font-heading font-bold text-dark leading-none mb-1">Puzzle<span class="text-blue">Maker</span></h1>
                    <p class="text-[10px] text-slate-400 font-black uppercase tracking-[0.2em]">English 1 Hub</p>
                </div>
            </div>
        </header>

        <div class="flex-1 space-y-6 overflow-y-auto pr-2 custom-scrollbar">
            <!-- Step 1: Manage Pages (New) -->
            <section>
                <div class="flex items-center justify-between mb-3">
                    <label class="input-label mb-0"><i data-lucide="layers" class="w-3 h-3"></i> 1. Pages / Rounds</label>
                    <button onclick="document.getElementById('fileInput').click()" class="text-[10px] font-black text-blue uppercase bg-blue/10 px-2 py-1 rounded hover:bg-blue/20 transition-colors">
                        + Add Page
                    </button>
                </div>
                
                <div id="roundsList" class="space-y-2 mb-2">
                    <!-- Rounds injected here -->
                </div>

                <div class="relative group mt-2" id="uploadBtnContainer">
                    <button onclick="document.getElementById('fileInput').click()" class="w-full btn-chunky bg-slate-100 text-slate-400 border-slate-300 h-12 text-sm shadow-none hover:bg-white hover:text-blue hover:border-blue">
                        <i data-lucide="plus" class="w-4 h-4 mr-2"></i> 
                        <span>Add New Image</span>
                    </button>
                </div>
                <input type="file" id="fileInput" class="hidden" accept="image/*" onchange="handleImageUpload(event)">
            </section>

            <!-- Step 2: Grid -->
            <section class="space-y-4">
                <label class="input-label"><i data-lucide="grid" class="w-3 h-3"></i> 2. Grid Size</label>
                <div class="grid grid-cols-2 gap-4">
                    <div class="space-y-2">
                        <span class="text-[10px] font-bold text-slate-500 uppercase ml-1">Cols</span>
                        <div class="flex items-center border-2 border-dark rounded-xl bg-white overflow-hidden shadow-[2px_2px_0px_#1e293b]">
                            <button onclick="adjustGrid('cols', -1)" class="w-10 h-10 hover:bg-slate-100 font-bold border-r-2 border-slate-100 transition-colors">-</button>
                            <span id="displayCols" class="flex-1 text-center font-heading font-bold text-lg text-dark">3</span>
                            <button onclick="adjustGrid('cols', 1)" class="w-10 h-10 hover:bg-slate-100 font-bold border-l-2 border-slate-100 transition-colors">+</button>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <span class="text-[10px] font-bold text-slate-500 uppercase ml-1">Rows</span>
                        <div class="flex items-center border-2 border-dark rounded-xl bg-white overflow-hidden shadow-[2px_2px_0px_#1e293b]">
                            <button onclick="adjustGrid('rows', -1)" class="w-10 h-10 hover:bg-slate-100 font-bold border-r-2 border-slate-100 transition-colors">-</button>
                            <span id="displayRows" class="number-display flex-1 text-center font-heading font-bold text-lg text-dark">3</span>
                            <button onclick="adjustGrid('rows', 1)" class="w-10 h-10 hover:bg-slate-100 font-bold border-l-2 border-slate-100 transition-colors">+</button>
                        </div>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-2">
                    <button onclick="setPreset(2)" class="text-[10px] font-black border-2 border-dark rounded-lg py-2 bg-white shadow-[2px_2px_0_#1e293b] text-dark hover:bg-slate-50">EASY</button>
                    <button onclick="setPreset(4)" class="text-[10px] font-black border-2 border-dark rounded-lg py-2 bg-white shadow-[2px_2px_0_#1e293b] text-dark hover:bg-slate-50">MID</button>
                    <button onclick="setPreset(6)" class="text-[10px] font-black border-2 border-dark rounded-lg py-2 bg-white shadow-[2px_2px_0_#1e293b] text-dark hover:bg-slate-50">HARD</button>
                </div>
            </section>

            <!-- Step 3: Options -->
            <section class="space-y-4">
                <label class="input-label"><i data-lucide="sliders" class="w-3 h-3"></i> 3. Style Options</label>
                <div onclick="togglePuzzleStyle()" class="toggle-btn" id="styleToggleBtn">
                    <span class="text-xs font-black uppercase tracking-wider">Jigsaw Edges</span>
                    <i data-lucide="puzzle" class="w-6 h-6 toggle-icon" id="styleIcon"></i>
                </div>
                <div onclick="toggleHints()" class="toggle-btn" id="hintToggleBtn">
                    <span class="text-xs font-black uppercase tracking-wider">Number Hints</span>
                    <i data-lucide="circle-dot" class="w-6 h-6 toggle-icon" id="hintIcon"></i>
                </div>
            </section>

            <!-- Step 4: Play -->
            <section class="space-y-3 pt-6 border-t-2 border-slate-100">
                <button onclick="scramblePuzzle()" id="btnScramble" class="w-full btn-chunky bg-orange text-white h-12" disabled>
                    <i data-lucide="shuffle" class="w-4 h-4 mr-2"></i> SCRAMBLE & PLAY
                </button>
                <button onclick="toggleSolve()" id="btnSolve" class="w-full btn-chunky bg-white text-dark h-12" disabled>
                    <i data-lucide="eye" class="w-4 h-4 mr-2"></i> REVEAL HINT
                </button>
            </section>

            <!-- Step 5: Print -->
            <section class="pt-6">
                <button onclick="openPrintModal()" id="btnPrint" class="w-full btn-chunky bg-green text-dark h-14" disabled>
                    <i data-lucide="printer" class="w-5 h-5 mr-3"></i> PRINT OPTIONS
                </button>
            </section>
        </div>

        <button onclick="clearStorage()" class="mt-8 py-3 text-[11px] font-black text-slate-300 hover:text-pink uppercase flex items-center justify-center gap-2 border-t-2 border-dashed border-slate-200 w-full">
            <i data-lucide="trash-2" class="w-3 h-3"></i> RESET APP
        </button>
    </aside>

    <!-- Main Area -->
    <main class="main-area">
        <!-- Fullscreen Toggle Button -->
        <button id="fullscreenToggle" onclick="toggleSidebar()">
            <i data-lucide="maximize-2" id="fsIcon" class="w-6 h-6"></i>
        </button>

        <div id="placeholder" class="text-center p-16 bg-white border-4 border-dark rounded-[48px] max-w-sm" style="box-shadow: 16px 16px 0 rgba(30, 41, 59, 0.1)">
            <div class="w-24 h-24 bg-orange/10 border-4 border-orange rounded-3xl flex items-center justify-center mx-auto mb-8 -rotate-6" style="box-shadow: 4px 4px 0 var(--color-orange)">
                <i data-lucide="image" class="text-orange w-12 h-12"></i>
            </div>
            <h2 class="font-heading text-3xl font-bold text-dark mb-4">Start Here</h2>
            <p class="text-slate-500 font-body mb-10 text-lg">Add your first puzzle page using the sidebar button!</p>
            <button onclick="document.getElementById('fileInput').click()" class="btn-chunky bg-blue text-white mx-auto text-lg px-8">
                SELECT IMAGE
            </button>
        </div>

        <!-- Hint Overlay -->
        <img id="thumb-preview" src="" alt="Hint">

        <div id="game-container">
            <canvas id="puzzleCanvas"></canvas>
        </div>

        <div id="liveStats" class="hidden fixed bottom-10 left-1/2 -translate-x-1/2 flex items-stretch gap-3 no-print z-40">
            <!-- Give Up Button -->
            <button onclick="giveUp()" class="bg-white border-4 border-dark px-4 rounded-2xl flex items-center justify-center shadow-[4px_4px_0_rgba(0,0,0,0.2)] hover:bg-pink hover:text-white hover:border-pink transition-colors group" title="Give Up">
                <i data-lucide="flag" class="w-6 h-6 text-pink group-hover:text-white"></i>
            </button>

            <!-- Stats -->
            <div class="bg-white border-4 border-dark px-6 py-3 rounded-2xl flex items-center gap-3 shadow-[6px_6px_0_rgba(0,0,0,0.2)]">
                <i data-lucide="timer" class="text-blue w-6 h-6"></i>
                <span id="timerDisplay" class="font-heading font-bold text-2xl text-dark">00:00</span>
            </div>
            <div class="bg-white border-4 border-dark px-6 py-3 rounded-2xl flex items-center gap-3 shadow-[6px_6px_0_rgba(0,0,0,0.2)]">
                <i data-lucide="mouse-pointer-2" class="text-orange w-6 h-6"></i>
                <span id="movesDisplay" class="font-heading font-bold text-2xl text-dark">0</span>
            </div>

             <!-- Next Button (Hidden unless next exists) -->
             <button id="liveNextBtn" onclick="nextRound()" class="bg-blue border-4 border-blue px-4 rounded-2xl flex items-center justify-center shadow-[4px_4px_0_rgba(0,0,0,0.2)] text-white hover:-translate-y-1 transition-transform hidden">
                <i data-lucide="arrow-right" class="w-6 h-6"></i>
            </button>
        </div>
    </main>

    <div id="print-area"></div>

    <script>
        const state = {
            rounds: [],        
            activeRound: 0,    
            tabSize: 0.18,
            printReference: false,
            timer: null,
            start: 0
        };

        const STORAGE_KEY = 'english1_puzzle_state_v5'; // Bumped version for new name field
        const canvas = document.getElementById('puzzleCanvas');
        const ctx = canvas.getContext('2d');
        const printModal = document.getElementById('printModal');
        const gameContainer = document.getElementById('game-container');
        const placeholder = document.getElementById('placeholder');
        const timerDisplay = document.getElementById('timerDisplay');
        const movesDisplay = document.getElementById('movesDisplay');
        const thumb = document.getElementById('thumb-preview');
        const stats = document.getElementById('liveStats');
        const toast = document.getElementById('toast');
        const roundsList = document.getElementById('roundsList');
        const sidebar = document.getElementById('sidebar');

        // Helper to get current round object safely
        function getCurrentRound() {
            return state.rounds[state.activeRound];
        }

        // --- NEW FUNCTIONS ---
        function toggleSidebar() {
            sidebar.classList.toggle('hidden-panel');
            const icon = document.getElementById('fsIcon');
            if (sidebar.classList.contains('hidden-panel')) {
                icon.innerHTML = lucide.icons['minimize-2'].toSvg(); // Actually shows expand icon logic inverted
                // Wait for transition to finish then resize
                setTimeout(resize, 310);
            } else {
                icon.innerHTML = lucide.icons['maximize-2'].toSvg();
                setTimeout(resize, 310);
            }
        }

        function giveUp() {
            const r = getCurrentRound();
            if (!r || !r.isActive) return;

            r.isActive = false;
            clearInterval(state.timer);
            
            // Solve visually
            r.tiles.forEach(t => { t.curC = t.c; t.curR = t.r; });
            
            draw();
            saveState();
            
            // Show toast instead of winner modal for giving up
            toast.innerHTML = '<i data-lucide="flag" class="w-4 h-4 text-pink"></i> <span>Puzzle Skipped</span>';
            showToast();
            
            // Check for next round button
            updateNextBtnVisibility();
        }

        function nextRound() {
            if (state.activeRound < state.rounds.length - 1) {
                closeModal('winnerModal');
                switchToRound(state.activeRound + 1);
            }
        }

        function updateNextBtnVisibility() {
            const hasNext = state.activeRound < state.rounds.length - 1;
            const liveBtn = document.getElementById('liveNextBtn');
            const modalBtn = document.getElementById('modalNextBtn');
            
            if (hasNext) {
                liveBtn.classList.remove('hidden');
                modalBtn.style.display = 'flex';
            } else {
                liveBtn.classList.add('hidden');
                modalBtn.style.display = 'none';
            }
        }

        function renameRound(e, idx) {
            e.stopPropagation();
            const r = state.rounds[idx];
            const newName = prompt("Enter a name for this puzzle:", r.name || `Page ${idx + 1}`);
            if (newName) {
                r.name = newName;
                renderRoundsList();
                saveState();
            }
        }

        // --- PERSISTENCE ---
        function saveState() {
            try {
                const data = {
                    activeRound: state.activeRound,
                    rounds: state.rounds.map(r => ({
                        name: r.name, // Save name
                        imgData: r.imgData,
                        cols: r.cols,
                        rows: r.rows,
                        puzzleStyle: r.puzzleStyle,
                        showHints: r.showHints,
                        moves: r.moves,
                        isActive: r.isActive,
                        secondsElapsed: r.secondsElapsed,
                        tiles: r.tiles,
                        edges: r.edges
                    }))
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                // Toast logic moved to specific actions to avoid spam
            } catch (e) {
                console.warn("Storage quota exceeded.");
            }
        }

        function showToast() {
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 2000);
            lucide.createIcons();
        }

        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return;
                const data = JSON.parse(saved);

                state.activeRound = data.activeRound || 0;
                
                if (data.rounds && data.rounds.length > 0) {
                    let loadedCount = 0;
                    data.rounds.forEach((r, idx) => {
                        const img = new Image();
                        img.onload = () => {
                            state.rounds[idx].imgObj = img; 
                            loadedCount++;
                            if (loadedCount === data.rounds.length) {
                                renderRoundsList();
                                switchToRound(state.activeRound);
                            }
                        };
                        img.src = r.imgData;
                        state.rounds.push({
                            ...r,
                            name: r.name || `Page ${idx + 1}`, // Default name if missing
                            timer: null
                        });
                    });
                }
            } catch (e) {
                console.error("Error loading state:", e);
                localStorage.removeItem(STORAGE_KEY); 
            }
        }

        function clearStorage() {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }

        // --- ROUND MANAGEMENT ---
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const tempImg = new Image();
                tempImg.onload = () => {
                    const maxDim = 1200; 
                    let w = tempImg.width;
                    let h = tempImg.height;
                    
                    if (w > maxDim || h > maxDim) {
                        const ratio = Math.min(maxDim / w, maxDim / h);
                        w *= ratio;
                        h *= ratio;
                    }
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(tempImg, 0, 0, w, h);
                    
                    const compressedDataUrl = tempCanvas.toDataURL('image/jpeg', 0.8);
                    
                    const finalImg = new Image();
                    finalImg.onload = () => {
                        addNewRound(finalImg, compressedDataUrl);
                        e.target.value = '';
                    };
                    finalImg.src = compressedDataUrl;
                };
                tempImg.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addNewRound(imgObj, imgData) {
            const newRound = {
                name: `Page ${state.rounds.length + 1}`,
                imgObj: imgObj,
                imgData: imgData,
                cols: 3,
                rows: 3,
                tiles: [],
                edges: { h: [], v: [] },
                puzzleStyle: 'jigsaw',
                showHints: false,
                moves: 0,
                isActive: false,
                secondsElapsed: 0,
                timer: null
            };
            
            generateTilesForRound(newRound);
            state.rounds.push(newRound);
            state.activeRound = state.rounds.length - 1;
            
            renderRoundsList();
            switchToRound(state.activeRound);
            saveState();
            
            toast.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green"></i> <span>Page Added</span>';
            showToast();
        }

        function deleteRound(e, idx) {
            e.stopPropagation();
            if (confirm("Remove this page?")) {
                state.rounds.splice(idx, 1);
                if (state.rounds.length === 0) {
                    location.reload();
                } else {
                    state.activeRound = Math.max(0, state.activeRound - 1);
                    renderRoundsList();
                    switchToRound(state.activeRound);
                    saveState();
                }
            }
        }

        function renderRoundsList() {
            roundsList.innerHTML = '';
            state.rounds.forEach((r, idx) => {
                const div = document.createElement('div');
                div.className = `round-item ${idx === state.activeRound ? 'active' : ''}`;
                div.onclick = () => switchToRound(idx);
                
                div.innerHTML = `
                    <div class="relative w-12 h-12 flex-shrink-0">
                        <img src="${r.imgData}" alt="Round ${idx + 1}">
                        <div class="absolute -top-1 -right-1 bg-blue text-white text-[9px] font-bold w-4 h-4 rounded-full flex items-center justify-center">${idx + 1}</div>
                    </div>
                    <div class="flex-1 min-w-0">
                        <h4 class="font-bold text-dark text-xs truncate">${r.name}</h4>
                        <p class="text-[10px] text-slate-400 font-bold">${r.cols}x${r.rows}</p>
                    </div>
                    <div class="flex flex-col gap-1">
                        <button onclick="renameRound(event, ${idx})" class="p-1 text-slate-300 hover:text-blue transition-colors" title="Rename">
                            <i data-lucide="pencil" class="w-3 h-3"></i>
                        </button>
                        <button onclick="deleteRound(event, ${idx})" class="p-1 text-slate-300 hover:text-pink transition-colors" title="Delete">
                            <i data-lucide="trash-2" class="w-3 h-3"></i>
                        </button>
                    </div>
                `;
                roundsList.appendChild(div);
            });
            lucide.createIcons();
            document.getElementById('printPageCount').textContent = state.rounds.length;
        }

        function switchToRound(idx) {
            clearInterval(state.timer);
            state.activeRound = idx;
            const r = getCurrentRound();
            
            renderRoundsList();

            if (!r) {
                placeholder.style.display = 'block';
                gameContainer.style.display = 'none';
                return;
            }

            placeholder.style.display = 'none';
            gameContainer.style.display = 'block';
            ['btnScramble', 'btnSolve', 'btnPrint'].forEach(id => document.getElementById(id).disabled = false);

            document.getElementById('displayCols').textContent = r.cols;
            document.getElementById('displayRows').textContent = r.rows;
            updateStyleUI(r);
            updateHintUI(r);
            movesDisplay.textContent = r.moves;
            timerDisplay.textContent = formatTime(r.secondsElapsed);
            thumb.src = r.imgData;
            thumb.style.display = 'none';

            if (r.isActive) {
                stats.classList.remove('hidden');
                state.start = Date.now() - (r.secondsElapsed * 1000);
                state.timer = setInterval(updTimer, 1000);
            } else {
                stats.classList.add('hidden');
            }

            // Check if next button should be shown (e.g., if already solved/given up and not last round)
            updateNextBtnVisibility();

            resize();
            draw();
        }

        // --- GAME LOGIC ---
        function generateTilesForRound(round) {
            round.tiles = [];
            round.edges.h = [];
            round.edges.v = [];

            for (let r = 0; r < round.rows; r++) {
                const row = [];
                for (let c = 0; c < round.cols - 1; c++) row.push(Math.random() < 0.5 ? 1 : -1);
                round.edges.h.push(row);
            }
            for (let r = 0; r < round.rows - 1; r++) {
                const row = [];
                for (let c = 0; c < round.cols; c++) row.push(Math.random() < 0.5 ? 1 : -1);
                round.edges.v.push(row);
            }

            for (let r = 0; r < round.rows; r++) {
                for (let c = 0; c < round.cols; c++) {
                    round.tiles.push({ c, r, curC: c, curR: r, id: r * round.cols + c + 1 });
                }
            }
        }

        function drawTileShape(ctx, c, r, w, h, x, y, round) {
            const ts = Math.min(w, h) * state.tabSize;
            ctx.beginPath();
            ctx.moveTo(x, y);

            if (r === 0 || round.puzzleStyle === 'grid') ctx.lineTo(x + w, y);
            else drawEdge(ctx, x, y, x + w, y, round.edges.v[r - 1][c], ts);

            if (c === round.cols - 1 || round.puzzleStyle === 'grid') ctx.lineTo(x + w, y + h);
            else drawEdge(ctx, x + w, y, x + w, y + h, round.edges.h[r][c], ts);

            if (r === round.rows - 1 || round.puzzleStyle === 'grid') ctx.lineTo(x, y + h);
            else drawEdge(ctx, x + w, y + h, x, y + h, -round.edges.v[r][c], ts);

            if (c === 0 || round.puzzleStyle === 'grid') ctx.lineTo(x, y);
            else drawEdge(ctx, x, y + h, x, y, -round.edges.h[r][c - 1], ts);

            ctx.closePath();
        }

        function drawEdge(ctx, x1, y1, x2, y2, side, ts) {
            const cx = (x1 + x2) / 2, cy = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const nx = -dy / Math.sqrt(dx * dx + dy * dy), ny = dx / Math.sqrt(dx * dx + dy * dy);
            const p1x = x1 + dx * 0.35, p1y = y1 + dy * 0.35;
            const p2x = x1 + dx * 0.35 + nx * ts * side, p2y = y1 + dy * 0.35 + ny * ts * side;
            const p3x = x1 + dx * 0.65 + nx * ts * side, p3y = y1 + dy * 0.65 + ny * ts * side;
            const p4x = x1 + dx * 0.65, p4y = y1 + dy * 0.65;
            ctx.lineTo(p1x, p1y); ctx.bezierCurveTo(p2x, p2y, p3x, p3y, p4x, p4y); ctx.lineTo(x2, y2);
        }

        function draw() {
            const r = getCurrentRound();
            if (!r || !r.imgObj) return;

            const tw = canvas.width / r.cols, th = canvas.height / r.rows;
            const iw = r.imgObj.width / r.cols, ih = r.imgObj.height / r.rows;
            const bleed = Math.min(tw, th) * state.tabSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            r.tiles.forEach((t, i) => {
                const dx = t.curC * tw, dy = t.curR * th;
                const sx = t.c * iw, sy = t.r * ih;
                ctx.save();
                drawTileShape(ctx, t.curC, t.curR, tw, th, dx, dy, r);
                ctx.clip();
                ctx.drawImage(r.imgObj, sx - (iw * state.tabSize), sy - (ih * state.tabSize), iw + (iw * state.tabSize * 2), ih + (ih * state.tabSize * 2), dx - bleed, dy - bleed, tw + bleed * 2, th + bleed * 2);
                ctx.restore();
                ctx.save();
                drawTileShape(ctx, t.curC, t.curR, tw, th, dx, dy, r);
                ctx.lineWidth = 4; 
                ctx.strokeStyle = r.isActive ? 'rgba(255,255,255,0.8)' : 'rgba(30,41,59,0.3)';
                ctx.stroke();
                
                if (i === state.selectedIdx) { 
                    ctx.strokeStyle = '#2979FF'; 
                    ctx.lineWidth = 6; 
                    ctx.stroke(); 
                    ctx.fillStyle = 'rgba(41, 121, 255, 0.2)'; 
                    ctx.fill(); 
                }
                ctx.restore();
                
                if (r.showHints) {
                    ctx.fillStyle = r.isActive ? 'rgba(255,255,255,0.95)' : 'rgba(30,41,59,0.5)';
                    ctx.font = `bold ${Math.min(tw, th) * 0.35}px Fredoka`;
                    ctx.textAlign = 'center';
                    ctx.fillText(t.id, dx + tw/2, dy + th/2 + 10);
                }
            });
        }

        canvas.addEventListener('click', (e) => {
            const r = getCurrentRound();
            if (!r || !r.isActive) return;

            const rect = canvas.getBoundingClientRect();
            const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * sx, y = (e.clientY - rect.top) * sy;
            const c = Math.floor(x / (canvas.width / r.cols));
            const row = Math.floor(y / (canvas.height / r.rows));
            
            const idx = r.tiles.findIndex(t => t.curC === c && t.curR === row);
            if (idx === -1) return;

            if (state.selectedIdx === -1) state.selectedIdx = idx;
            else if (state.selectedIdx === idx) state.selectedIdx = -1;
            else {
                const t1 = r.tiles[state.selectedIdx], t2 = r.tiles[idx];
                [t1.curC, t2.curC] = [t2.curC, t1.curC];
                [t1.curR, t2.curR] = [t2.curR, t1.curR];
                state.selectedIdx = -1; 
                r.moves++; 
                movesDisplay.textContent = r.moves;
                checkWin();
                saveState();
            }
            draw();
        });

        function checkWin() {
            const r = getCurrentRound();
            if (r.tiles.every(t => t.c === t.curC && t.r === t.curR)) {
                r.isActive = false; 
                clearInterval(state.timer);
                document.getElementById('finalTime').textContent = timerDisplay.textContent;
                document.getElementById('finalMoves').textContent = r.moves;
                
                // Show modal
                setTimeout(() => document.getElementById('winnerModal').classList.add('active'), 400);
                
                // Show next button if available
                updateNextBtnVisibility();
                
                saveState();
                draw();
            }
        }

        function scramblePuzzle() {
            const r = getCurrentRound();
            if(!r) return;
            
            const pos = [];
            for (let row=0; row<r.rows; row++) for (let c=0; c<r.cols; c++) pos.push({c, row});
            pos.sort(() => Math.random() - 0.5);
            r.tiles.forEach((t, i) => { t.curC = pos[i].c; t.curR = pos[i].row; });
            
            r.isActive = true; 
            state.selectedIdx = -1; 
            r.moves = 0;
            movesDisplay.textContent = '0'; 
            stats.classList.remove('hidden');
            document.getElementById('liveNextBtn').classList.add('hidden'); // Hide next button during play
            
            clearInterval(state.timer); 
            r.secondsElapsed = 0;
            state.start = Date.now();
            state.timer = setInterval(updTimer, 1000);
            draw();
            saveState();
        }

        function toggleSolve() {
            if (!getCurrentRound()) return;
            const isShown = thumb.style.display === 'block';
            thumb.style.display = isShown ? 'none' : 'block';
        }

        function updTimer() {
            const r = getCurrentRound();
            if(!r || !r.isActive) return;
            
            r.secondsElapsed = Math.floor((Date.now() - state.start) / 1000);
            timerDisplay.textContent = formatTime(r.secondsElapsed);
            if (r.secondsElapsed % 5 === 0) saveState(); 
        }
        
        function formatTime(sec) {
            return `${Math.floor(sec/60).toString().padStart(2,'0')}:${(sec%60).toString().padStart(2,'0')}`;
        }

        function adjustGrid(k, v) {
            const r = getCurrentRound();
            if (!r || r.isActive) return;
            r[k] = Math.max(2, Math.min(10, r[k] + v));
            document.getElementById(k === 'cols' ? 'displayCols' : 'displayRows').textContent = r[k];
            renderRoundsList();
            generateTilesForRound(r);
            draw(); 
            saveState();
        }

        function setPreset(n) {
            const r = getCurrentRound();
            if (!r || r.isActive) return;
            r.cols = n; r.rows = n;
            document.getElementById('displayCols').textContent = n;
            document.getElementById('displayRows').textContent = n;
            renderRoundsList();
            generateTilesForRound(r);
            draw();
            saveState();
        }

        function togglePuzzleStyle() {
            const r = getCurrentRound();
            if(!r) return;
            r.puzzleStyle = r.puzzleStyle === 'jigsaw' ? 'grid' : 'jigsaw';
            updateStyleUI(r);
            draw();
            saveState();
        }

        function toggleHints() {
            const r = getCurrentRound();
            if(!r) return;
            r.showHints = !r.showHints;
            updateHintUI(r);
            draw();
            saveState();
        }

        function updateStyleUI(r) {
            const btn = document.getElementById('styleToggleBtn');
            const icon = document.getElementById('styleIcon');
            if (r.puzzleStyle === 'jigsaw') {
                btn.classList.add('active');
                icon.innerHTML = lucide.icons['puzzle'].toSvg({ strokeWidth: 3 });
            } else {
                btn.classList.remove('active');
                icon.innerHTML = lucide.icons['grid'].toSvg({ strokeWidth: 2 });
            }
        }

        function updateHintUI(r) {
            const btn = document.getElementById('hintToggleBtn');
            const icon = document.getElementById('hintIcon');
            if (r.showHints) {
                btn.classList.add('active');
                icon.innerHTML = lucide.icons['check-circle-2'].toSvg({ strokeWidth: 3 });
            } else {
                btn.classList.remove('active');
                icon.innerHTML = lucide.icons['circle'].toSvg({ strokeWidth: 2 });
            }
        }

        function resize() {
            const r = getCurrentRound();
            if (!r || !r.imgObj) return;
            
            // Adjust max width based on sidebar state
            const isFullscreen = sidebar.classList.contains('hidden-panel');
            const mw = window.innerWidth - (isFullscreen ? 80 : 440); // 80px margin for fullscreen
            const mh = window.innerHeight - 180;
            
            const ratio = Math.min(mw / r.imgObj.width, mh / r.imgObj.height);
            canvas.width = r.imgObj.width * ratio; 
            canvas.height = r.imgObj.height * ratio;
            
            gameContainer.style.width = canvas.width + 'px';
            gameContainer.style.height = canvas.height + 'px';
            draw();
        }

        window.onresize = resize;
        function closeModal(id) { document.getElementById(id).classList.remove('active'); }
        function openPrintModal() { printModal.classList.add('active'); }

        function togglePrintOpt(opt) {
            if (opt === 'reference') {
                state.printReference = !state.printReference;
                const box = document.getElementById('opt-reference');
                const check = document.getElementById('check-reference');
                if (state.printReference) {
                    box.classList.add('border-orange');
                    check.classList.add('bg-orange');
                    check.innerHTML = lucide.icons['check'].toSvg({color: "white", width: 16});
                } else {
                    box.classList.remove('border-orange');
                    check.classList.remove('bg-orange');
                    check.innerHTML = '';
                }
            }
        }

        function executePrint() {
            const printArea = document.getElementById('print-area');
            printArea.innerHTML = '';

            state.rounds.forEach((r, idx) => {
                const puzzlePage = document.createElement('div');
                puzzlePage.className = 'print-page';
                puzzlePage.setAttribute('data-page-num', `${r.name} - Puzzle`); // Use custom name
                
                const pCanvas = document.createElement('canvas');
                pCanvas.width = r.imgObj.width;
                pCanvas.height = r.imgObj.height;
                const pCtx = pCanvas.getContext('2d');
                
                const tw = pCanvas.width / r.cols, th = pCanvas.height / r.rows;
                const iw = r.imgObj.width / r.cols, ih = r.imgObj.height / r.rows;
                const bleed = Math.min(tw, th) * state.tabSize;

                r.tiles.forEach(t => {
                    const dx = t.c * tw;
                    const dy = t.r * th;
                    const sx = t.c * iw, sy = t.r * ih;
                    
                    pCtx.save();
                    drawTileShape(pCtx, t.c, t.r, tw, th, dx, dy, r);
                    pCtx.clip();
                    pCtx.drawImage(r.imgObj, sx - (iw * state.tabSize), sy - (ih * state.tabSize), iw + (iw * state.tabSize * 2), ih + (ih * state.tabSize * 2), dx - bleed, dy - bleed, tw + bleed * 2, th + bleed * 2);
                    pCtx.restore();
                    
                    pCtx.save();
                    drawTileShape(pCtx, t.c, t.r, tw, th, dx, dy, r);
                    pCtx.lineWidth = 2; 
                    pCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                    pCtx.stroke();
                    pCtx.restore();
                });

                const imgContainer = document.createElement('div');
                imgContainer.className = 'print-full-img';
                const pImg = document.createElement('img');
                pImg.src = pCanvas.toDataURL(); 
                imgContainer.appendChild(pImg);
                puzzlePage.appendChild(imgContainer);
                printArea.appendChild(puzzlePage);
            });

            if (state.printReference) {
                state.rounds.forEach((r, idx) => {
                    const refPage = document.createElement('div');
                    refPage.className = 'print-page print-page-ref';
                    refPage.setAttribute('data-page-num', `${r.name} - Answer`);
                    refPage.innerHTML = `
                        <div class="print-header">
                            <div>
                                <h1 class="text-3xl font-heading font-bold text-dark">Answer Key</h1>
                                <p class="text-xs font-bold uppercase tracking-widest text-slate-400 mt-1">${r.name}</p>
                            </div>
                        </div>
                    `;
                    const refContainer = document.createElement('div');
                    refContainer.style.width = '100%';
                    refContainer.style.flex = '1';
                    refContainer.style.display = 'flex';
                    refContainer.style.justifyContent = 'center';
                    refContainer.style.alignItems = 'flex-start';
                    const rImg = document.createElement('img');
                    rImg.src = r.imgData;
                    rImg.style.maxWidth = '100%';
                    rImg.style.maxHeight = '220mm';
                    rImg.style.objectFit = 'contain';
                    rImg.style.border = '2px solid #000';
                    refContainer.appendChild(rImg);
                    refPage.appendChild(refContainer);
                    printArea.appendChild(refPage);
                });
            }

            lucide.createIcons();
            setTimeout(() => {
                window.print();
                printModal.classList.remove('active');
            }, 800);
        }

        window.onload = () => {
            loadState(); 
            lucide.createIcons();
        };
    </script>
</body>
</html>