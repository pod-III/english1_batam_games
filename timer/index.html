<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classroom Timers: Zen & Boom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&family=Share+Tech+Mono&display=swap');

        :root {
            --color-pink: #FF6B9C;
            --color-orange: #FF9F43;
            --color-green: #2ECC71;
            --color-blue: #54A0FF;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            overflow-x: hidden;
        }

        /* Animations for Calm Mode */
        @keyframes breathe {
            /* Kept the same scale range */
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .zen-circle {
            /* Now set to a very slow, smooth 30-second cycle (15s in, 15s out) */
            animation: breathe 30s infinite linear alternate;
        }

        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 4s infinite ease-in-out;
        }

        /* Animations for Bomb Mode */
        @keyframes tick-tock {
            0% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
            100% { transform: rotate(-2deg); }
        }

        @keyframes shake-mild {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        @keyframes shake-hard {
            0% { transform: translate(0px, 0px) rotate(0deg); }
            25% { transform: translate(5px, 5px) rotate(5deg); }
            50% { transform: translate(0px, 5px) rotate(0deg); }
            75% { transform: translate(-5px, 5px) rotate(-5deg); }
            100% { transform: translate(0px, 0px) rotate(0deg); }
        }

        @keyframes fuse-spark {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.5); }
            100% { opacity: 1; transform: scale(1); }
        }

        .bomb-active {
            animation: tick-tock 1s infinite;
        }

        .shake-mild {
            animation: shake-mild 0.5s infinite;
        }

        .shake-hard {
            animation: shake-hard 0.1s infinite;
        }

        .digital-font {
            font-family: 'Share Tech Mono', monospace;
        }

        /* Mode Transitions */
        .mode-transition {
            transition: background-color 0.5s ease, color 0.5s ease;
        }

        /* Explosion Overlay */
        #explosion-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: white;
            z-index: 50;
            align-items: center;
            justify-content: center;
        }
        
        .boom-text {
            font-size: 8rem;
            font-weight: 900;
            color: var(--color-orange);
            text-shadow: 4px 4px var(--color-pink);
            animation: scale-up 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes scale-up {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }

        /* Input Styling */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
            font-family: inherit;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col mode-transition" id="main-body">

    <!-- Header / Mode Switcher -->
    <nav class="w-full p-4 flex justify-between items-center bg-white/80 backdrop-blur-md shadow-sm z-10 sticky top-0">
        <div class="flex items-center gap-2">
            <i data-lucide="gamepad-2" class="w-6 h-6 text-gray-700"></i>
            <h1 class="text-xl font-bold text-gray-700">Teacher's Game Hub</h1>
        </div>
        
        <div class="flex bg-gray-100 p-1 rounded-full">
            <button onclick="setMode('calm')" id="btn-calm" class="px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2">
                <i data-lucide="leaf"></i> Zen Flow
            </button>
            <button onclick="setMode('bomb')" id="btn-bomb" class="px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2">
                <i data-lucide="bomb"></i> Fuse Rush
            </button>
        </div>
    </nav>

    <!-- Main Content Area -->
    <main class="flex-grow flex items-center justify-center p-4 relative overflow-hidden">
        
        <!-- Background Decor (Dynamic) -->
        <div id="bg-decor" class="absolute inset-0 pointer-events-none z-0"></div>

        <!-- Timer Container -->
        <div id="timer-container" class="relative z-10 bg-white/90 backdrop-blur rounded-3xl shadow-2xl p-8 w-full max-w-md text-center transition-all duration-300">
            
            <!-- Timer Display -->
            <div class="mb-8 relative">
                <!-- Visual Element (Circle or Bomb) -->
                <div id="visual-element" class="h-48 w-48 mx-auto mb-6 flex items-center justify-center transition-all">
                    <!-- Content injected by JS -->
                </div>

                <!-- Digital Numbers (Editable Inputs) -->
                <div id="time-display-container" class="flex justify-center items-center text-6xl font-bold text-gray-800 transition-colors gap-1">
                    <input type="number" id="min-input" value="05" min="0" max="99" 
                           class="w-24 text-center bg-transparent focus:outline-none focus:bg-white/50 focus:ring-2 ring-blue-300 transition-all rounded-xl p-1 cursor-pointer hover:bg-black/5" 
                           onchange="updateTimeFromInput()" onfocus="stopTimer(); this.select()" 
                           aria-label="Minutes">
                    <span class="pb-4 select-none">:</span>
                    <input type="number" id="sec-input" value="00" min="0" max="59" 
                           class="w-24 text-center bg-transparent focus:outline-none focus:bg-white/50 focus:ring-2 ring-blue-300 transition-all rounded-xl p-1 cursor-pointer hover:bg-black/5" 
                           onchange="updateTimeFromInput()" onfocus="stopTimer(); this.select()"
                           aria-label="Seconds">
                </div>
            </div>

            <!-- Controls -->
            <div class="flex flex-col gap-4">
                <!-- Time Adjusters -->
                <div class="flex justify-center flex-wrap gap-2 text-sm text-gray-500 font-mono">
                    <button onclick="adjustTime(-60)" class="hover:bg-red-50 hover:text-red-500 hover:border-red-200 px-3 py-1 rounded border border-gray-200 transition-colors bg-white">-1m</button>
                    <button onclick="adjustTime(-30)" class="hover:bg-red-50 hover:text-red-500 hover:border-red-200 px-3 py-1 rounded border border-gray-200 transition-colors bg-white">-30s</button>
                    <div class="w-px bg-gray-300 mx-1 hidden sm:block"></div>
                    <button onclick="adjustTime(30)" class="hover:bg-green-50 hover:text-green-500 hover:border-green-200 px-3 py-1 rounded border border-gray-200 transition-colors bg-white">+30s</button>
                    <button onclick="adjustTime(60)" class="hover:bg-green-50 hover:text-green-500 hover:border-green-200 px-3 py-1 rounded border border-gray-200 transition-colors bg-white">+1m</button>
                    <button onclick="adjustTime(300)" class="hover:bg-green-50 hover:text-green-500 hover:border-green-200 px-3 py-1 rounded border border-gray-200 transition-colors bg-white">+5m</button>
                </div>

                <!-- Play/Pause/Reset -->
                <div class="flex justify-center gap-4 mt-2">
                    <button onclick="toggleTimer()" id="start-btn" class="w-16 h-16 rounded-full flex items-center justify-center text-white text-xl shadow-lg transform transition active:scale-95 hover:shadow-xl">
                        <i data-lucide="play" id="play-icon"></i>
                    </button>
                    
                    <button onclick="resetTimer()" class="w-16 h-16 rounded-full bg-gray-200 text-gray-600 flex items-center justify-center text-xl shadow hover:bg-gray-300 transform transition active:scale-95">
                        <i data-lucide="rotate-ccw"></i>
                    </button>
                </div>
            </div>
            
            <!-- Status Text -->
            <p id="status-text" class="mt-6 text-gray-500 font-medium">Ready to start</p>
        </div>
    </main>

    <!-- Explosion Overlay -->
    <div id="explosion-overlay">
        <div class="text-center">
            <div class="boom-text">BOOM!</div>
            <p class="text-2xl mt-4 text-gray-600 font-bold">Time's Up!</p>
            <button onclick="closeExplosion()" class="mt-8 px-8 py-3 bg-gray-800 text-white rounded-full hover:bg-gray-700 transition font-bold">
                Reset
            </button>
        </div>
    </div>

    <script>
        // State
        let timeLeft = 300; // 5 minutes in seconds
        let initialTime = 300;
        let isRunning = false;
        let intervalId = null; // 1-second interval for digital time/core logic
        let progressUpdateId = null; // Fast interval for smooth progress bar update
        let startTime = 0; // The timestamp when the timer started
        let currentMode = 'calm'; // 'calm' or 'bomb'
        
        // Audio Context (Browser requires user interaction to start audio)
        let audioCtx;

        // Elements
        const body = document.getElementById('main-body');
        const displayContainer = document.getElementById('time-display-container');
        const minInput = document.getElementById('min-input');
        const secInput = document.getElementById('sec-input');
        
        const visualElement = document.getElementById('visual-element');
        const startBtn = document.getElementById('start-btn');
        const playIcon = document.getElementById('play-icon');
        const statusText = document.getElementById('status-text');
        const timerContainer = document.getElementById('timer-container');
        const bgDecor = document.getElementById('bg-decor');
        const explosionOverlay = document.getElementById('explosion-overlay');

        // Colors
        const colors = {
            green: '#2ECC71',
            blue: '#54A0FF',
            orange: '#FF9F43',
            pink: '#FF6B9C',
            darkRed: '#d63031'
        };

        // --- Initialization ---
        lucide.createIcons();
        setMode('calm'); // Default

        // --- Logic ---

        function setMode(mode) {
            currentMode = mode;
            stopTimer(); // Pause if switching

            const btnCalm = document.getElementById('btn-calm');
            const btnBomb = document.getElementById('btn-bomb');

            if (mode === 'calm') {
                // UI Styles
                body.style.backgroundColor = '#EBFBF2'; // Light Green tint
                btnCalm.className = "px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2 bg-green-500 text-white shadow-md";
                btnBomb.className = "px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2 text-gray-500 hover:bg-gray-200";
                startBtn.style.backgroundColor = colors.blue;
                
                displayContainer.classList.remove('digital-font', 'text-red-500');
                displayContainer.classList.add('text-gray-800');
                
                timerContainer.classList.remove('shake-mild', 'shake-hard');
                
                // Visuals
                updateCalmVisuals();
                statusText.innerText = "Focus & Breathe";
                
                // Decor
                bgDecor.innerHTML = `
                    <div class="bubble w-32 h-32 top-10 left-10 bg-green-200 opacity-20"></div>
                    <div class="bubble w-24 h-24 bottom-20 right-20 bg-blue-200 opacity-20"></div>
                    <div class="bubble w-16 h-16 top-1/2 left-1/4 bg-blue-100 opacity-20"></div>
                `;

            } else {
                // UI Styles
                body.style.backgroundColor = '#FFF0E6'; // Light Orange tint
                btnBomb.className = "px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2 bg-orange-500 text-white shadow-md";
                btnCalm.className = "px-4 py-2 rounded-full text-sm font-semibold transition-all flex items-center gap-2 text-gray-500 hover:bg-gray-200";
                startBtn.style.backgroundColor = colors.pink;
                
                displayContainer.classList.add('digital-font'); // Monospaced for bomb
                
                // Visuals
                updateBombVisuals();
                statusText.innerText = "Detonation Sequence";

                // Decor
                bgDecor.innerHTML = `
                   <div class="absolute top-0 left-0 w-full h-2 bg-[repeating-linear-gradient(45deg,${colors.orange},${colors.orange}_10px,transparent_10px,transparent_20px)] opacity-50"></div>
                   <div class="absolute bottom-0 left-0 w-full h-2 bg-[repeating-linear-gradient(45deg,${colors.pink},${colors.pink}_10px,transparent_10px,transparent_20px)] opacity-50"></div>
                `;
            }
            // Update display only when changing modes or when stopped/reset
            if (!isRunning) updateDisplay(true);
        }

        // Flag to control if we update inputs (only needed on 1s tick or initialization)
        function updateDisplay(isOneSecondTick = false) { 
            const m = Math.floor(timeLeft / 60);
            const s = timeLeft % 60;
            
            // Only update inputs if they are not currently being focused/edited 
            // AND it's a 1-second tick or initial load
            if (isOneSecondTick && document.activeElement !== minInput && document.activeElement !== secInput) {
                minInput.value = m.toString().padStart(2, '0');
                secInput.value = s.toString().padStart(2, '0');
            }
            
            // Dynamic Updates based on mode (Only update static visuals if NOT running in calm mode)
            if (currentMode === 'calm' && !isRunning) {
                updateCalmVisuals();
            } else if (currentMode === 'bomb') {
                updateBombVisuals();
            }
        }

        function updateTimeFromInput() {
            let m = parseInt(minInput.value) || 0;
            let s = parseInt(secInput.value) || 0;
            
            // Basic validation
            if (s > 59) { m += Math.floor(s/60); s = s % 60; }
            if (m > 99) m = 99;

            timeLeft = (m * 60) + s;
            initialTime = timeLeft > 0 ? timeLeft : 300; // Reset initial time base for visuals
            
            // Force update formatting (e.g. if user typed "5", make it "05")
            minInput.value = m.toString().padStart(2, '0');
            secInput.value = s.toString().padStart(2, '0');
            
            // If the timer is stopped, update the visual to the new input time
            if (!isRunning) updateDisplay(true);
        }

        function adjustTime(seconds) {
            let newTime = timeLeft + seconds;
            if (newTime < 0) newTime = 0;
            timeLeft = newTime;
            
            // If we are adding time, we might want to update the "initialTime" 
            if (timeLeft > initialTime) initialTime = timeLeft;
            
            updateDisplay(true);
            
            // If running in calm mode, restart the smooth progress calculation from the new time
            if (isRunning && currentMode === 'calm') {
                startTime = Date.now() - (initialTime - timeLeft) * 1000;
            }
        }

        function toggleTimer() {
            if (!audioCtx) initAudio(); // Start audio context on first user click

            if (isRunning) {
                stopTimer();
            } else {
                startTimer();
            }
        }

        function startTimer() {
            // Update values from input one last time before starting to be sure
            updateTimeFromInput();
            
            if (timeLeft <= 0) return;
            
            isRunning = true;
            playIcon.setAttribute('data-lucide', 'pause');
            lucide.createIcons();
            
            if (currentMode === 'bomb') {
                statusText.innerText = "Fuse Lit!";
                statusText.style.color = colors.orange;
            } else {
                statusText.innerText = "Flowing...";
                statusText.style.color = colors.green;
            }

            // 1. Core Timer (decrements the displayed time every second)
            intervalId = setInterval(() => {
                timeLeft--;
                updateDisplay(true); // Update digital time every second
                
                // Sound Effects
                if (currentMode === 'bomb') {
                    playTickSound();
                }

                // Bomb Panic Logic
                if (currentMode === 'bomb' && timeLeft <= 10 && timeLeft > 0) {
                     timerContainer.classList.add('shake-mild');
                     displayContainer.classList.add('text-red-600');
                     displayContainer.classList.remove('text-gray-800');
                }
                
                if (currentMode === 'bomb' && timeLeft <= 5 && timeLeft > 0) {
                     timerContainer.classList.remove('shake-mild');
                     timerContainer.classList.add('shake-hard');
                     body.style.backgroundColor = (timeLeft % 2 === 0) ? '#ffcccb' : '#FFF0E6'; // Flash red
                }

                if (timeLeft <= 0) {
                    finishTimer();
                }
            }, 1000);
            
            // 2. Smooth Visual Update (runs frequently to animate the progress bar)
            if (currentMode === 'calm') {
                startTime = Date.now() - (initialTime - timeLeft) * 1000; // Calculate accurate start time
                progressUpdateId = setInterval(smoothProgressUpdate, 50); // 50ms = 20 FPS for smooth progress
            }
        }

        function stopTimer() {
            isRunning = false;
            clearInterval(intervalId);
            clearInterval(progressUpdateId); // Clear fast interval
            progressUpdateId = null;

            playIcon.setAttribute('data-lucide', 'play');
            lucide.createIcons();
            statusText.innerText = "Paused";
            statusText.style.color = 'gray';
            
            // Clear Bomb FX
            timerContainer.classList.remove('shake-mild', 'shake-hard');
            if(currentMode === 'bomb') body.style.backgroundColor = '#FFF0E6';
        }

        function resetTimer() {
            stopTimer();
            timeLeft = initialTime > 0 ? initialTime : 300;
            if(currentMode === 'bomb') {
                displayContainer.classList.remove('text-red-600');
                displayContainer.classList.add('text-gray-800');
            }
            updateDisplay(true); // Force display update
            statusText.innerText = "Ready";
        }

        function finishTimer() {
            stopTimer();
            timeLeft = 0;
            updateDisplay(true);

            if (currentMode === 'bomb') {
                playExplosionSound();
                explosionOverlay.style.display = 'flex';
            } else {
                playCalmChime();
                statusText.innerText = "Session Complete";
                // Gentle pulse
                const circle = document.querySelector('.zen-circle');
                if(circle) circle.style.transform = 'scale(1.2)';
            }
        }

        function closeExplosion() {
            explosionOverlay.style.display = 'none';
            resetTimer();
        }

        // This runs frequently (e.g., every 50ms) to update the visual progress smoothly.
        function smoothProgressUpdate() {
            if (currentMode !== 'calm' || !isRunning || initialTime === 0) return;

            // Calculate elapsed time based on the actual start time
            const elapsed = (Date.now() - startTime) / 1000; // seconds
            
            // Calculate current time remaining
            const currentTotalTime = Math.max(0, initialTime - elapsed);
            
            // Calculate percentage remaining
            const pct = currentTotalTime / initialTime;

            // Update the progress visual based on the smooth percentage
            const dashArray = 283; // 2 * pi * 45
            const dashOffset = dashArray * (1 - pct);

            const progressCircle = document.getElementById('progress-circle');
            if (progressCircle) {
                progressCircle.style.strokeDashoffset = dashOffset;
            }
            
            // If the progress bar hits zero, make sure to stop the interval
            if (currentTotalTime <= 0) {
                 clearInterval(progressUpdateId);
                 progressUpdateId = null;
            }
        }


        // --- Visual Generators ---

        function updateCalmVisuals() {
            // Visualize percentage remaining as a water level or simple circle stroke
            const pct = Math.max(0, timeLeft / initialTime);
            // We'll create an SVG circle that "drains"
            const dashArray = 283; // 2 * pi * 45
            const dashOffset = dashArray * (1 - pct);

            visualElement.innerHTML = `
                <div class="relative w-full h-full flex items-center justify-center">
                    <svg class="w-full h-full transform -rotate-90 zen-circle" viewBox="0 0 100 100">
                        <!-- Track -->
                        <circle cx="50" cy="50" r="45" fill="none" stroke="#E2E8F0" stroke-width="8" />
                        <!-- Progress -->
                        <circle cx="50" cy="50" r="45" fill="none" stroke="${colors.green}" stroke-width="8" 
                                stroke-dasharray="${dashArray}" 
                                stroke-linecap="round" 
                                id="progress-circle"
                                style="transition: none;" /> <!-- Transition removed for JS control -->
                    </svg>
                    <i data-lucide="leaf" class="absolute text-green-400 w-12 h-12 opacity-80"></i>
                </div>
            `;
            // Manually set initial offset (since we removed the CSS transition)
            const progressCircle = document.getElementById('progress-circle');
            if (progressCircle) {
                 progressCircle.style.strokeDashoffset = dashOffset;
            }
            lucide.createIcons();
        }

        function updateBombVisuals() {
            // Visualize a cartoon bomb with a fuse that shortens
            const pct = Math.max(0, timeLeft / initialTime);
            const fuseWidth = pct * 60; // Max width in SVG units
            
            // Change bomb color based on urgency
            let bombColor = '#374151'; // Dark Gray
            let fuseColor = colors.orange;
            
            if (timeLeft <= 10) {
                bombColor = '#991B1B'; // Red
                fuseColor = '#FF0000';
            }

            visualElement.innerHTML = `
                 <svg class="w-full h-full drop-shadow-lg" viewBox="0 0 100 100">
                    <!-- Fuse Line -->
                    <path d="M50 20 Q 60 5, 80 15" fill="none" stroke="#666" stroke-width="3" />
                    
                    <!-- Burning Part of Fuse (Dynamic) -->
                    <line x1="80" y1="15" x2="${80 - (1-pct)*30}" y2="${15 + (1-pct)*5}" stroke="${fuseColor}" stroke-width="4" stroke-dasharray="2,2" />
                    
                    <!-- Spark -->
                    <circle cx="${80 - (1-pct)*30}" cy="${15 + (1-pct)*5}" r="3" fill="#FFEAA7" class="animate-pulse">
                        <animate attributeName="r" values="3;5;3" dur="0.2s" repeatCount="indefinite" />
                    </circle>

                    <!-- Bomb Body -->
                    <circle cx="50" cy="60" r="30" fill="${bombColor}" />
                    <!-- Shine -->
                    <path d="M40 50 Q 45 45, 50 50" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="3" stroke-linecap="round"/>
                    
                    <!-- Skull Icon inside -->
                    <text x="50" y="68" font-size="20" text-anchor="middle" fill="white" opacity="0.8" style="font-family: sans-serif">â˜ </text>
                </svg>
            `;
        }

        // --- Audio Generation (Web Audio API) ---
        // Generates sounds via code so no external assets are needed.
        
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }

        function playTickSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            // Different tick pitch for urgency
            osc.frequency.value = timeLeft <= 10 ? 800 : 400; 
            osc.type = 'square';
            
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playExplosionSound() {
            if (!audioCtx) return;
            const duration = 1.0;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            // White noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const gainNode = audioCtx.createGain();
            // Start loud, fade out
            gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            
            // Lowpass filter to make it sound like an explosion (deep boom)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + duration);

            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            noise.start();
        }

        function playCalmChime() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.frequency.setValueAtTime(440, audioCtx.currentTime); // A4
            osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1); // Slide up to A5
            
            osc.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 2);
        }

    </script>
</body>
</html>